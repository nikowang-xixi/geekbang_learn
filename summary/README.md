## 毕业总结

历经了2个月学习后, Java 进阶训练营迎来了快要结营, 极客大学推出的内容质量还是不错的。经过了那么多周的学习, 在秦老师的帮助下构建好了 Java 的知识体系, 达到了进阶的目的，这 15 周多的训练营下来，完成的作业的题目不是很理想，完成的范围基本上都是必做作业。 训练营结束不是终点，是新的起点，在接下来的一年以内，我会努力将进阶和挑战作业都做一做，来加强一下训练营学习的知识点。
秦老师也看到了我们的成长, 我很庆幸参与了《Java 进阶训练营》3期, 在这一期的收获, 远远不止 Java 进阶这么一件事情, 秦老师还言传身教, 让我们明白了技术人应该怎么样去思考和规划自己的职业生涯, 如何去学习, 在一段工作经历中如何保持离开的能力等等,
我认为最大的收获, 参与了《Java 进阶训练营》后, 我真的是越学习越想学, 希望以后还能继续和老师还有同学们持续交流和成长。

## 学习总结

### JVM

JVM 是 Java 程序运行时的 "操作系统", 管理着 Java 程序运行时的资源 (内存, 类的字节码等等)。作为 Java 工程师, 我们需要了解:

#### Java字节码

* 这个 "操作系统" 是如何将我们编写的类加载到运行时环境的 (类加载机制)
    * JDK 中有哪些类加载器？
    * 为什会有 Java 的类加载机制会有 "双亲委派" 模型: 为了安全, 特定的类只有由特定的加载器加载; 如何打破双亲委派模型(1. Java SPI机制，如JDBC, 2. OSGi)
    * 如何自己实现一个 ClassLoader 来加载我们自己的类: ClassLoader 中的方法 `loadClass` 定义如何载入一个类, `findClass` 定义了如何查找一个类, `defineClass` 定义了如何从字节数组组装一个类信息
    * 类加载和卸载的过程, 理解类加载的过程能够让我们了解一个类中变量的生命周期, 从而在线上问题处理的时候更多地了解支撑程序运行的一个个 class 的状况

* 理解 Java 的字节码, 能够让我们能基于字节码这种 "黑魔法" 去做一些字节码的定制, 比如对字节码进行加密防止类的反编译

#### 类的生命周期

类从被加载到被卸载, 经历了哪些过程。

#### JVM 内存模型JMM

- JMM构成，每个部分的作用
- 并发相关
    - JSR-133 规范， happen-before
    - happen-before, as-if-serial

#### JVM启动参数

JVM 启动参数相当于时 JVM 这个 "操作系统" 的运行时参数, 影响了 JVM 的运行时行为

- 标准参数、非标参数、非稳定参数
- 场景：GC 调优

#### Java agent, Instrument

- 应用场景：APM，如 skywalking, pinpoint

### GC

#### GC 基本理论

- 如何判断对象是垃圾？
    - 引用计数: 无法解决循环引用计数问题
    - GC Roots: 静态字段，活动线程，当前正执行的方法里的局部变量和输入参数，JNI 引用
- 垃圾回收算法, 3 种类型：
    - 标记-清理
    - 标记-整理
    - 复制算法
- 分代回收思想
    - eden, survivor, old
    - 对象头中有 4 位 2 进制保存年代数，所以最大也就到 15

#### 常见 GC 算法

##### Serial + Serial Old

- 有STW
- 单线程
- **年轻代：复制算法，老年代：标记-整理**
- 低延迟GC

##### Parallel Scavenge + Parallel Old

- 并发标记、并发回收，只不过将 Serial + Serial Old 中的单线程变成多线程
- **年轻代：复制算法，老年代：标记-整理**
- **高吞吐量GC**

##### ParNew + CMS

- ParNew 其实是 Parallel Scavenge 的改进，只是为了能支持 CMS
- 初始标记 -> 并发标记 -> 重新标记 -> 并发清理
- 初始标记、重新标记会 STW
- **年轻代：复制算法，老年代：标记-清除算法**
- **低延迟 GC **
- CMS 存在浮动垃圾问题，因为并发清理阶段相当于边回收、边创造垃圾。如果回收不过来，将会调用 Serial Old、单线程回收。

##### G1

- 将堆内存划分成多个 region， region 分为：eden, survivor, old, humongous 这 4 种。
- 每次 GC 不再收集整个堆，而是只处理一部分
- 理论上不应该触发 full gc
- 存在 mixed gc, 过程与 CMS 基本一致

##### ZGC 和 Shenandoah

- 低延迟 GC，最大停顿时间不超过 10ms

#### 如何选择GC

##### 一般性原则

- 若希望系统吞吐优先：Parallel Scavenge + Parallel Old
- 若希望系统低延迟优先，每次GC时间尽量短：CMS
- 若系统内存堆较大，且希望平均GC时间可控：G1

##### 从内存看

- 一般 4G 以上，G1 性价比比较高
- 超过 8G，非常推荐 G1

### NIO

#### Java 中网络 IO 类库 Socket

#### NIO模型与相关概念

#### IO 相关的基本概念

- 阻塞、非阻塞是线程处理模式
- 同步、异步是通信模式

#### 常见 IO 模型

- 同步阻塞IO(BIO)
    - 典型：平时我们手写的java socket
- 同步非阻塞IO
    - 由于非阻塞，不管是否拿到结果都会立即返回，需要不断轮询直到拿到数据
- IO多路复用(NIO)
    - 仍是同步、阻塞IO
    - 如果没有拿到数据，当前线程会一直阻塞，由操作系统内核去监听、拿到数据后返回
        - linux的select/poll/epoll的区别
            - select、poll都需要轮询，select有文件描述符fd上限的问题（可以通过改变宏定义或是重新编译内核，但太麻烦），并且每次都会对所有socket做一次线性扫描，浪费了一定开销。时间复杂度O(n)
            - poll与select基本一样，但不会有文件描述符fd上限的问题，基于链表，但还是需要遍历所有fd、时间复杂度O(n)
            - epoll适合于处理大量的fd ，且活跃fd不是很多的情况。只告知那些就绪的文件描述符。时间复杂度O(1)
- 信号驱动IO(SIGIO)
- 异步IO（AIO）

#### 网络通讯框架 Netty

- 异步、事件驱动、基于NIO
- 为何快？
    - 基于NIO
    - 零拷贝：注意，与Kafka那个不一样，Kafka零拷贝是操作系统层面上的，减少了用户态与内核态之间来回拷贝数据；Netty是在用户态，更多的是数据操作的优化。
    - Reactor模型
- 基本概念
    - Channel & ChannelPipeline
    - ChannelFuture
    - Event & Handler
    - Encoder & Decoder
    - EventLoop
    - Bootstrap
- 常见问题
    - 粘包与拆包
        - 解决：自定义协议，指定报文长度（与HTTP报文设计思想是一样的）
    
#### 并发编程

- 线程基础 状态转换（RR —WW—B）
- JUC并发包下的原子类、工具类、锁、线程池
- ThreadLocal

#### Spring 和 ORM 等框架

- Spring (core,web,mvc,DataBase,messaging) 理解类加载过程
- Springboot (自动装配原理，各种starter ,熟练自定义starter)
- ORM技术体系 （JPA,Hibernate,Mybatis）
- 常用的提效框架（Java8,Guava等）
- 设计原则：LOSID
- 设计模式（创建型、结构型、行为型）

#### MySQL 数据库和 SQL

- mysql基础 （事务、索引、锁、针对innodb引擎 的mvcc 、gap锁等）
- 事务（ACID）
- 查询优化（索引失效、不精确分页、减少锁的范围）
- 高可用高性能（读写分离、主从复制、主从切换）
- 分库分表、分布式主键、分表算法、数据迁移等
- 常用的数据库中间件（ss、mycat、TDDL）
- XA、柔性事务（TCC、TAC）

#### RPC 和微服务

- 基础知识（RPC）
- 常见的RPC技术（老牌：JSONRpc，XMLRpc,Webservice 近代：Hessian、Thrift、GRPC等）
- 自定义RPC框架需要考虑的因素（传输协议、序列化方式、客户端存根方式，服务端存根方式、共享接口定义 是类 还是IDL）
- 分布式服务的治理套装
- 常用框架（Dubbo、SpringCloud生态体系）
- 从微服务到服务网格到云原生

#### 分布式缓存

- 本地缓存、集中式缓存
- 常见缓存问题（穿透，击穿、雪崩）万金油方式：异步缓存
- 缓存中间件 redis (基本功能、六大使用场景) 常用的redis客户端
- AOF 、RDB
- redis 常见的数据结构，分布式锁、
- 应用场景业务缓存，排行榜、lua支持session共享分布式id 等
- redis集群与高可用
- 内存网格Hazelcast

#### 分布式消息队列

- 消息队列的基础知识（消息模式、消息协议、消息保障机制、）
- 主流mq(activemq,rabbitmq,kafka,rocketmq,Pulsar)
- 高可用（集群、分区、副本）
- mq的应用场景
- 思考手动实现一个消息队列的方式

#### 分布式架构

- 业务分析
- 功能性需求
- 非功能性需求
- 高可用、高性能、稳定性、可扩展性、易用性、安全性
- 业务视图，逻辑视图、架构视图、开发视图、部署视图
- 分布式服务化、消息中间件、数据库中间件、分布式存储、权限控制等

#### 业务系统重构

- 分析系统现状、了解各方的期望与差距
- 给出可选方案，明确优缺点提供决策依据
- 各方适当妥协达成一致
- 细化方案争取资源与时间
- 小步快跑迅速取得阶段性成果,不影响业务的发展
- 监控保障，特性开关
- 方法与经验的沉淀